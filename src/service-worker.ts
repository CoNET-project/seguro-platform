/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate } from 'workbox-strategies'
declare const self: ServiceWorkerGlobalScope
clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')
const siteMatch = /webpack\.config\.js|robots\.txt|service-worker\.js(\..*)?|service-worker.jsrobots\.txt|manifest\.json|logo\d{3}\.png|index\.html|encrypt\.js|asset\-manifest\.json|(^\/s|^s)tatic\/|favicon\.ico$|sw\.js|encrypt\.js$|utilities\/(Pouchdb|seguroSetup|Buffer|openpgp|UuidV4|Pouchdb|PouchdbFind|PouchdbMemory|scrypt|async|forge.all|jszip|utilities|web3|generatePassword|storage|seguroSetup])\.(min\.)?(js|js\.map)$/i
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }: { request: Request; url: URL }) => {
		// If this isn't a navigation, skip.
		
		if (request.mode !== 'navigate') {
			return false
		}

		// If this is a URL that starts with /_, skip.
		if (url.pathname.startsWith('/_')) {
			return false
		}

		// If this looks like a URL for a resource, because it contains
		// a file extension, skip.
		if (url.pathname.match(fileExtensionRegexp)) {
			return false
		}

		if (url.pathname.match(siteMatch)) {
			true
		}

		// Return true to signal that we want to use the handler.
		return false
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
// registerRoute(
// 	// Add in any other file extensions or routing criteria as needed.
// 	({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
// 	// Customize this strategy as needed, e.g., by changing to CacheFirst.
// 	new StaleWhileRevalidate({
// 		cacheName: 'images',
// 		plugins: [
// 		// Ensure that once this runtime cache reaches a maximum size the
// 		// least-recently used images are removed.
// 		new ExpirationPlugin({ maxEntries: 50 }),
// 		],
// 	})
// )

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
// self.addEventListener('message', (event) => {
// 	if (event.data && event.data.type === 'SKIP_WAITING') {
// 		self.skipWaiting()
// 	}
// })



self.addEventListener( "fetch", e => {
	startRouter (e)
})


// Any other custom service worker logic can go here.
import {v4, validate} from 'uuid'
import {Buffer} from 'buffer'
type WorkerCommand =
	'urlProxy'
	
type IWorker_command = {
	cmd: WorkerCommand
	data: any[]
	uuid: string
	err?: string
}


const logger = (...argv: any ) => {
    const date = new Date ()
    const dateStrang = `%c [Seguro-worker INFO ${ date.getHours() }:${ date.getMinutes() }:${ date.getSeconds() }:${ date.getMilliseconds ()}]`
	
    return console.log ( dateStrang, 'color: #dcde56',  ...argv)
}

const err_response_network_err = () => new Response('',{ status: 599, statusText: "NetworkConnectTimeoutError!" })
const err_response_404 = () => new Response('',{ status: 404, statusText: "File Not Found!" })

interface clientPool {
	clientId: {
		resultingClientId: string
		clientId: string
	}
	siteOrigin: URL
	node: any
}

interface workPromise {
	cmd: IWorker_command
	uuid: string
	_promise: (value: IWorker_command | PromiseLike<IWorker_command>) => void
}

interface urlData {
	href: string
	port: number
	method: string
	json: string
}

let CoNETWorkerClient = ''
const backGroundPool: workPromise[] = []

const listenChannel = new BroadcastChannel('toServiceWroker')

listenChannel.addEventListener('message', e => {
	let cmd: IWorker_command
	try {
		cmd = JSON.parse(e.data)
	} catch (ex) {
		logger (`************************************************** toServiceWroker BroadcastChannel JSON parse Error`)
		return logger (e)
	}
	if (cmd.err) {
		
		logger (`************************************************** toServiceWroker BroadcastChannel get Error return`)
		return logger (cmd)
	}
	switch (cmd.cmd) {
		case 'urlProxy': {

			const index = backGroundPool.findIndex( n => {
				return (n.cmd.uuid == cmd.uuid)
			})
			if (index < 0) {
				return logger (`Service Worker ERROR listenChannel [toServiceWroker] got unknow UUID message!`, cmd)
			}
			
			const jobQueue = backGroundPool[index]
			return jobQueue._promise (cmd)
		}
		default: {
			logger (`Service Worker ERROR listenChannel [toServiceWroker] got unknow message!`, cmd)
		}
	}
})

const clientDomainPool: clientPool[] = []

const readRequestBody: (request: Request) => Promise<ArrayBuffer|null> = (request) => new Promise( async (resolve) => {

	const content = await request.blob()
	const reader = new FileReader()
	reader.onload = () => {
		return resolve(
			//@ts-ignore
			reader.result)
	}
	reader.readAsBinaryString(content)
	
})

const channel = new BroadcastChannel('toMainWroker')

const sendUrlToWorker: (urlData: urlData, headers: Object, gateway: Object) => Promise<IWorker_command> = (urlData, headers, gateway) => {
	return new Promise ( resolve => {
		const cmd: IWorker_command = {
			cmd: 'urlProxy',
			uuid: v4(),
			data: [urlData, headers, gateway]
		}
		
		channel.postMessage(JSON.stringify(cmd))
		backGroundPool.push ({
			_promise: resolve,
			cmd,
			uuid: cmd.uuid
		})
	})
}

/**
 * 			https://github.githubassets.com:8888/assets/chunk-ui_packages_webauthn-get-element_webauthn-get-element_ts-1afa9dfc8ee5.js
 */

const startRouter = (event: FetchEvent ) => {

	const accessHref = event.request.url
	const accessHrefUrl = new URL (accessHref)


	let clientId = {
		resultingClientId: event.resultingClientId,
		clientId: event.clientId,
	}

	logger (`****************************** accessHref = ${accessHref}`, event)
	let reqUrl = accessHref.split('_/CoNET_proxyUrl/')[1]
	let siteMaster = false
	
	let gateway = null
	
	const locationReg = new RegExp(location.host,'i')
	
	if (!reqUrl ) {
		if (CoNETWorkerClient === event.clientId) {
			return logger (`--------------------------- SKIP core access! brcause CoNETWorkerClient[${CoNETWorkerClient}] === event.clientId`, accessHref)
		}
		//		pass CoNET SI access from Worker!
		if(/openpgp\.online\/post$/.test(accessHref)) {
			CoNETWorkerClient = event.clientId
			logger (`---------------------------  [${ accessHref }] --------------------------- SKIP core access! `)
			return 
		}

		//		pass from CoNET core access
		if (siteMatch.test(accessHref)) {
			CoNETWorkerClient = event.clientId
			logger (`--------------------------- [${ accessHref }]  Matched CoNET core system skip --------------------------- `)
			return
		}

		//		New Path for the iFrame need renew iFrame src
		//		
		if (event.resultingClientId) {

			logger (` ###############################  [${ accessHref }] has resultingClientId = [${event.resultingClientId}] no _/CoNET_proxyUrl/ part return 404 ############################### `)
			return err_response_404()
		}

		//		PATH has clientId
		const index = clientDomainPool.findIndex (n => n.clientId.resultingClientId === event.clientId )
		if (index < 0 ) {
			logger (`*************************  [${ accessHref }] Can't fing origin from clientDomainPool ************************ `)
			logger (clientId)
			logger (clientDomainPool)
			logger (`*************************  [${ accessHref }]  Can't fing origin from clientDomainPool ************************ `)
			return err_response_404()
		}
		const remote = clientDomainPool[index]

		//		src has same as location.host
		if (locationReg.test(accessHrefUrl.hostname)) {
			//const replaseSite = location.origin.replace('https://', ``)
			reqUrl = accessHref.replace ( location.origin, remote.siteOrigin.origin )
			
			gateway = remote.node

		}
		//		Direct to other domain in iFramer
		else {
			reqUrl = accessHref
		}
	}
	//		has reqUrl
	else {
		
		siteMaster = true
		if (event.clientId) {
			const index = clientDomainPool.findIndex (n => n.clientId.resultingClientId === event.clientId )
			if ( index > 0 ) {
				const remote = clientDomainPool[index]
				gateway = remote.node
				siteMaster = false
			}
		}
	}

	return event.respondWith(( async () => {
		const siteOrigin = new URL (reqUrl)
		const cacheStore = await caches.match(event.request)
			if (cacheStore) {
				return cacheStore
			}
			const urlData: urlData = {
				href: reqUrl,
				method: event.request.method,
				port: siteOrigin.port || /^http\:$/.test(siteOrigin.protocol) ? 80 : 443,
				json: ''
			}
			logger (`*********** clientId start Proxy *********************`)
			logger (urlData)
			logger (clientId)
			logger (`*********** clientId  start Proxy *********************`)
			const headers = event.request.headers
			const result: { [key: string]: string } = {}

			headers.forEach((v,k) => {
				result[k] = v.replace(location.origin, siteOrigin.origin)
			})

			console.log (result)
			
			if ( urlData.method !== 'GET') {
				logger (`${urlData.href} method = `, urlData.method )
				const body = await readRequestBody(event.request)
				if (body) {
					const ctArray = Array.from(new Uint8Array(body))
					const ctStr = ctArray.map(byte => String.fromCharCode(byte)).join('')
					urlData.json = btoa(ctStr)
				}

			}

			const cmd = await sendUrlToWorker(urlData, result, gateway)

			if (cmd.err) {
				return err_response_network_err()
			}

			if (siteMaster && clientId.resultingClientId) {
				const node =  cmd.data[3]
				const data: clientPool = {
					clientId,
					//	@ts-ignore
					siteOrigin, 
					node
				}
				clientDomainPool.push (data)
				logger (`*********** siteMaster *********************`)
				logger (data)
				logger (`*********** siteMaster *********************`)
			}
			
			const responseHeaders = cmd.data[1]
			logger (urlData)
			logger (cmd)


			const bb =cmd.data[0]

			const { status, statusText } = cmd.data[2]
			
			// logger (`status [${status}], statusText [${statusText}]`)
			
			const body = Buffer.from(bb,'binary').buffer
			return (new Response ( body, {
				status,
				statusText,
				headers: {...responseHeaders }
			}))
			
	})())
}